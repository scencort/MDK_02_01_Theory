### 1. Понятия требований, классификация
Вот более развернутый, но всё ещё компактный ответ для экзамена:

**Требования** — это условия или возможности, которым должна соответствовать система для удовлетворения нужд пользователей и заказчиков.

**Классификация требований:**
1. **По содержанию:**
   - **Функциональные требования** — описывают, какие функции должна выполнять система (например, «система должна хранить данные о пользователях»).
   - **Нефункциональные требования** — определяют качественные характеристики системы: производительность, надёжность, безопасность, удобство использования и др.
2. **По уровню:**
   - **Бизнес-требования** — цели организации, которых должна достичь система.
   - **Пользовательские требования** — задачи, которые пользователь сможет решать с помощью системы.
   - **Системные требования** — детализированные требования к самой системе, её компонентам и взаимодействию.
3. **По обязательности:**
   - **Обязательные** (must have) — без них система не будет функционировать.
   - **Желательные** (nice to have) — улучшают работу, но не критичны.

**Пример:**  
Функциональное требование: «Система должна отправлять письма пользователям».  
Нефункциональное: «Время отклика не должно превышать 2 секунд».

---

### 2. Уровни требований

**Уровни требований** — это различные ступени детализации описания того, что должна обеспечивать разрабатываемая система.

**Основные уровни требований:**

1. **Бизнес-требования**  
   - Описывают цели и задачи организации, которых должна достичь система.  
   - Формулируются на уровне бизнеса.  
   - Пример: "Увеличить прибыль компании за счет автоматизации продаж."
2. **Пользовательские требования**  
   - Показывают, что пользователь сможет делать с помощью системы.  
   - Задают поведение системы с точки зрения пользователя, часто оформляются как сценарии использования.  
   - Пример: "Пользователь может просматривать и редактировать свой профиль."
3. **Системные требования**  
   - Подробно описывают функции и характеристики системы, необходимые для реализации пользовательских требований.  
   - Являются основой для проектирования и тестирования.  
   - Пример: "Система должна хранить данные о пользователях в защищённой базе данных."

**Структура:**  
Бизнес-требования → Пользовательские требования → Системные требования

---

### 3. Методологии и стандарты, регламентирующие работу с требованиями
**Методологии и стандарты, регламентирующие работу с требованиями** — это формализованные подходы и документы, которые определяют процессы выявления, документирования, анализа и управления требованиями к системе.

**Основные методологии:**
- **Waterfall (Каскадная модель):** требования фиксируются на начальном этапе и практически не изменяются в ходе проекта.
- **Agile (Гибкие методологии):** требования формируются и уточняются итеративно, допускаются изменения на любом этапе (например, Scrum, Kanban).
- **RUP (Rational Unified Process):** требования уточняются поэтапно, акцент на управление изменениями.

**Основные стандарты:**
- **IEEE 830-1998:** стандарт по описанию требований к программному обеспечению (SRS — Software Requirements Specification).
- **ISO/IEC/IEEE 29148:** международный стандарт, объединяющий лучшие практики по управлению требованиями.
- **BABOK (Business Analysis Body of Knowledge):** свод знаний по бизнес-анализу, описывает процессы работы с требованиями.
- **ГОСТ 34.602-89 (для России):** стандарт по проектированию автоматизированных систем, включая работу с требованиями.

---

### 4. Современные принципы и методы разработки программных приложений

**Современные принципы и методы разработки программных приложений** — это подходы и правила, которые используются для эффективного и качественного создания программного обеспечения.

**Основные принципы:**
- **Модульность** — система строится из отдельных, независимых компонентов.
- **Повторное использование (reuse)** — использование существующих модулей или библиотек.
- **Гибкость и адаптивность** — возможность быстро вносить изменения в проект.
- **Ориентация на пользователя** — разработка ведётся с учетом удобства и потребностей конечного пользователя.
- **Автоматизация тестирования и сборки** — внедрение CI/CD, автоматических тестов.

**Современные методы разработки:**
- **Agile (гибкие методологии)** — итеративная разработка с постоянной обратной связью (например, Scrum, Kanban).
- **DevOps** — объединение процессов разработки и эксплуатации, автоматизация развертывания и тестирования.
- **Test-Driven Development (TDD)** — разработка через написание тестов до кода.
- **Continuous Integration/Continuous Delivery (CI/CD)** — непрерывная интеграция и доставка изменений в продукт.
- **Domain-Driven Design (DDD)** — проектирование системы на основе предметной области.

---

### 5. Методы организации работы в команде разработчиков

**Методы организации работы в команде разработчиков** — это подходы и практики, которые помогают эффективно управлять совместной работой над проектом, распределять задачи и достигать целей.

**Основные методы:**

- **Классические методы управления проектами**  
  — Жёсткая иерархия, чёткое распределение ролей и обязанностей (например, водопадная модель/Waterfall).

- **Гибкие (Agile) методологии**  
  — Командная работа организована итерациями, с постоянной обратной связью и адаптацией к изменяющимся требованиям.  
  — Популярные подходы:
    - **Scrum** — работа по спринтам, есть роли Product Owner, Scrum Master, команда разработки, ежедневные стендапы, планирование, ретроспективы.
    - **Kanban** — непрерывное движение задач по доске (визуализация процесса), гибкое распределение работы.
    - **Extreme Programming (XP)** — акцент на тесном взаимодействии, парное программирование, частые релизы.

- **DevOps**  
  — Объединение команд разработки и сопровождения, автоматизация процессов (CI/CD), совместная ответственность за продукт.

- **Матрица ответственности (RASCI, RACI)**  
  — Формализованное распределение ролей: кто отвечает, выполняет, согласует, консультирует и информирует по задачам.

- **Использование инструментов для совместной работы**  
  — Системы управления задачами (Jira, Trello), репозитории кода (GitHub, GitLab), мессенджеры и видеоконференции (Slack, Zoom).

---

### 6. Системы контроля версий

**Системы контроля версий** — это программные инструменты, предназначенные для хранения, отслеживания и управления изменениями в исходном коде или других файлах проекта.

**Основные задачи систем контроля версий:**
- Хранение истории изменений файлов.
- Совместная работа нескольких разработчиков.
- Возможность возврата к предыдущим версиям (откат изменений).
- Разветвление разработки (ветки/branches) и слияние изменений (merge).

**Типы систем контроля версий:**
- **Локальные** — хранят изменения только на одном компьютере (например, RCS).
- **Централизованные** — используют единый сервер для хранения истории (например, SVN, CVS).
- **Распределённые** — каждый участник имеет полную копию репозитория (например, Git, Mercurial).

**Популярные системы:**
- **Git** — самая распространённая, поддерживает распределённую работу, ветвление, используется на GitHub, GitLab, Bitbucket.
- **Subversion (SVN)** — централизованная система, раньше была стандартом для многих проектов.
- **Mercurial** — распределённая система, похожая на Git.

---

### 7. Основные подходы к интегрированию программных модулей

**Основные подходы к интегрированию программных модулей** — это методы, с помощью которых реализуется объединение отдельных частей (модулей) системы в единую рабочую программу.

**Основные подходы:**

- **Big Bang (Большой взрыв):**  
  Все модули разрабатываются отдельно, а затем интегрируются одновременно. Простой, но сложно выявлять ошибки.

- **Поэтапная (инкрементальная) интеграция:**  
  Модули объединяются постепенно, по одному или небольшими группами.  
  Варианты:
    - **Восходящая интеграция (Bottom-Up):** сначала объединяются нижние уровни, затем более высокие.
    - **Нисходящая интеграция (Top-Down):** интеграция начинается с самых верхних модулей и постепенно добавляются нижние.
    - **Смешанная (сэндвич) интеграция:** одновременно интегрируются верхние и нижние уровни, потом соединяются в середине.

- **Непрерывная интеграция (Continuous Integration, CI):**  
  Модули интегрируются автоматически и постоянно после каждого изменения, что позволяет быстро находить и исправлять ошибки.

---

### 8. Стандарты кодирования

**Стандарты кодирования** — это набор правил и рекомендаций, определяющих стиль написания кода, структуру файлов, оформления имен и другие аспекты программирования для обеспечения читаемости, поддержки и единого стиля в команде.

**Зачем нужны стандарты:**
- Повышают читаемость и понятность кода.
- Упрощают совместную работу и сопровождение проекта.
- Помогают избегать типичных ошибок.

**Основные аспекты стандартов:**
- Форматирование кода: отступы, длина строки, пробелы.
- Именование переменных, функций, классов (например, camelCase, snake_case).
- Комментирование и документация.
- Организация файлов и папок.
- Правила для обработки ошибок и исключений.
- Единые соглашения по использованию языковых конструкций и библиотек.

**Примеры стандартов:**
- **PEP 8** для Python.
- **Google Java Style Guide** для Java.
- **Airbnb JavaScript Style Guide** для JavaScript.
- В крупных компаниях часто есть собственные внутренние стандарты.

---

### 9. Описание требований: унифицированный язык моделирования - краткий словарь

**Описание требований: унифицированный язык моделирования (UML) — краткий словарь**

- **UML (Unified Modeling Language)** — унифицированный язык моделирования, стандарт для визуализации, описания и документирования программных систем.

**Основные элементы UML:**

- **Класс (Class)** — описание сущности с атрибутами и методами.
- **Объект (Object)** — экземпляр класса.
- **Атрибут (Attribute)** — свойство или характеристика класса.
- **Операция/метод (Operation/Method)** — действие, выполняемое классом.
- **Ассоциация (Association)** — связь между классами.
- **Агрегация (Aggregation)** — «целое-часть», слабая связь между объектами.
- **Композиция (Composition)** — «жёсткое целое-часть», сильная связь (часть не существует без целого).
- **Наследование (Generalization)** — отношение «родитель-потомок» между классами.
- **Взаимодействие (Interaction)** — обмен сообщениями между объектами.
- **Актор (Actor)** — внешний пользователь или система, взаимодействующая с системой.
- **Прецедент (Use Case)** — сценарий взаимодействия актора с системой.
- **Диаграмма классов (Class Diagram)** — отображает классы и отношения между ними.
- **Диаграмма прецедентов (Use Case Diagram)** — показывает акторов и их сценарии работы с системой.
- **Диаграмма последовательности (Sequence Diagram)** — описывает взаимодействие объектов во времени.
- **Диаграмма деятельности (Activity Diagram)** — моделирует процессы и потоки управления.

---

### 10. Диаграммы UML

**Диаграммы UML** — это графические схемы, применяемые для визуализации структуры, поведения и взаимодействия компонентов программных систем. UML (Unified Modeling Language, унифицированный язык моделирования) стандартизирует формы и обозначения таких диаграмм.


**Основные виды диаграмм UML:**

- **Диаграмма классов (Class Diagram)**  
  — Показывает классы системы, их атрибуты, методы и отношения (наследование, ассоциации, агрегации и композиции).

- **Диаграмма объектов (Object Diagram)**  
  — Отображает конкретные экземпляры классов и связи между ними на определённый момент времени.

- **Диаграмма прецедентов (Use Case Diagram)**  
  — Иллюстрирует взаимодействие акторов (пользователей или внешних систем) с системой через сценарии (use cases).

- **Диаграмма последовательности (Sequence Diagram)**  
  — Показывает порядок обмена сообщениями между объектами для выполнения определённого сценария.

- **Диаграмма деятельности (Activity Diagram)**  
  — Моделирует логику бизнес-процессов или алгоритмов, отображая последовательность действий и переходов.

- **Диаграмма состояний (State Machine Diagram)**  
  — Описывает состояния объекта и переходы между ними в ответ на события.

- **Диаграмма компонентов (Component Diagram)**  
  — Демонстрирует физические компоненты системы и их взаимосвязи.

- **Диаграмма развертывания (Deployment Diagram)**  
  — Показывает, как программные компоненты размещаются на оборудовании (узлах).

---

### 11. Описание и оформление требований (спецификация)

**Описание и оформление требований (спецификация)** — это процесс формализации требований к программному продукту в виде единого документа, который служит основой для разработки, тестирования и приёмки системы.

**Основные принципы описания требований:**
- Требования должны быть однозначными, полными, проверяемыми, реализуемыми и согласованными.
- Формулировки должны быть максимально точными, избегать двусмысленностей и субъективных оценок (“быстро”, “удобно”, “лучше”).

**Структура спецификации требований (на примере SRS — Software Requirements Specification):**
1. **Введение**
   - Цель документа
   - Область применения
   - Определения и сокращения
2. **Общее описание**
   - Перечень функций системы
   - Пользовательские характеристики
   - Ограничения и допущения
3. **Функциональные требования**
   - Описание функций системы, сценарии использования, реакции на события
4. **Нефункциональные требования**
   - Требования к производительности, безопасности, интерфейсам, совместимости и т.д.
5. **Требования к внешним интерфейсам**
   - Взаимодействие с другими системами и пользователями
6. **Критерии приёмки**
   - Условия, при которых работа будет считаться завершённой

**Оформление:**
- Использование шаблонов (например, IEEE 830, ГОСТ 34.602-89).
- Структурированное изложение (разделы, заголовки, списки).
- Таблицы, диаграммы UML для наглядности.
- Пронумерованные требования для удобства ссылок и отслеживания изменений.

---

### 12. Анализ требований и стратегии выбора решения

**Анализ требований и стратегии выбора решения** — это этапы разработки, на которых проводится оценка собранных требований и определяются подходящие способы их реализации.

**Анализ требований:**
- Включает изучение, уточнение, классификацию и приоритезацию требований.
- Проверяется полнота, согласованность, реализуемость, однозначность и тестируемость требований.
- Выявляются противоречия, дубли и пробелы.
- Формируется модель требований (диаграммы, сценарии, прототипы).

**Стратегии выбора решения:**
- **Сравнение альтернатив**: рассматриваются различные варианты реализации, оцениваются плюсы и минусы каждого (например, разные архитектуры, платформы, технологии).
- **Критерии выбора**: стоимость, сроки, риски, ресурсы, совместимость, масштабируемость, поддержка.
- **Прототипирование**: создание быстрых прототипов для проверки ключевых идей или технической осуществимости.
- **SWOT-анализ**: анализ сильных/слабых сторон, возможностей и угроз для каждого варианта.
- **Коллективное обсуждение**: проведение совещаний, мозговых штурмов, экспертных оценок.
- **Документирование решения**: выбранный вариант фиксируется и согласуется со всеми заинтересованными сторонами.

---

### 13. Цели и задачи, и виды тестирования

**Цели и задачи тестирования:**  
Тестирование — это процесс проверки программного обеспечения с целью выявления ошибок, повышения качества и подтверждения соответствия требованиям.

**Основные цели тестирования:**
- Обнаружение ошибок и дефектов до передачи продукта пользователю.
- Проверка соответствия ПО заявленным требованиям и ожиданиям заказчика.
- Повышение качества продукта (надёжность, производительность, удобство).
- Минимизация рисков, связанных с выпуском дефектного продукта.

**Задачи тестирования:**
- Разработка тестовых сценариев и данных.
- Проведение различных видов тестирования.
- Документирование обнаруженных дефектов.
- Анализ результатов тестирования и подготовка отчётов.
- Проверка исправлений и регрессий.

**Виды тестирования:**

1. **По уровню:**
   - **Модульное (Unit testing):** тестируются отдельные функции/модули.
   - **Интеграционное (Integration testing):** проверяется взаимодействие модулей между собой.
   - **Системное (System testing):** тестируется вся система в целом.
   - **Приёмочное (Acceptance testing):** проводится заказчиком для проверки готовности системы к эксплуатации.

2. **По степени автоматизации:**
   - **Ручное (Manual testing):** тестировщик выполняет тесты вручную.
   - **Автоматизированное (Automated testing):** используются специальные инструменты для автоматического выполнения тестов.

3. **По типу проверки:**
   - **Функциональное:** проверка соответствия функциональных требований.
   - **Нефункциональное:** тестирование производительности, безопасности, удобства использования и других характеристик.
   - **Регрессионное:** проверка, что новые изменения не нарушили работу существующих функций.
   - **Тестирование безопасности, нагрузочное, стрессовое и др.**

---

### 14. Стандарты качества программной документации

**Стандарты качества программной документации** — это совокупность правил и критериев, которым должна соответствовать документация к программному обеспечению, чтобы быть полезной, понятной и поддерживаемой.

**Основные характеристики качественной документации:**
- **Полнота** — вся нужная информация присутствует, нет пробелов.
- **Ясность и понятность** — текст написан простым и однозначным языком, понятен целевой аудитории.
- **Точность** — сведения соответствуют реальному поведению программы, отсутствуют ошибки и неточности.
- **Актуальность** — документация своевременно обновляется при изменении программы.
- **Структурированность** — логичная организация, наличие оглавления, разделов, списков, иллюстраций.
- **Доступность** — легко найти нужную информацию, применяется навигация, индекс, поиск.
- **Краткость** — отсутствие избыточной информации, всё по делу.
- **Согласованность** — единый стиль, терминология и форматирование по всему документу.

**Международные и национальные стандарты:**
- **ГОСТ 19.105-78** — Общие требования к программной документации (Россия, СНГ).
- **ГОСТ 34.602-89** — Техническое задание на создание АС.
- **ISO/IEC/IEEE 26514** — Международный стандарт по требованию к пользовательской документации.
- **IEEE 1063** — Стандарт по написанию пользовательской документации.

---

### 15. Меры и метрики

**Меры и метрики** — это количественные показатели, которые используются для оценки различных характеристик процесса и продукта разработки программного обеспечения.

**Меры** — это количественные значения, получаемые в результате измерения (например, количество строк кода, количество найденных дефектов).

**Метрики** — это производные показатели, которые вычисляются на основе мер для анализа и принятия решений (например, производительность команды, плотность дефектов).

**Примеры мер:**
- Количество строк исходного кода (LOC — Lines of Code)
- Число требований в спецификации
- Количество тестовых случаев
- Число выявленных дефектов

**Примеры метрик:**
- **Плотность дефектов:** количество ошибок на тысячу строк кода
- **Покрытие кода тестами:** процент кода, покрытого тестами
- **Среднее время исправления дефекта**
- **Производительность команды:** количество реализованных требований за спринт

**Для чего нужны меры и метрики:**
- Оценка качества продукта и процесса разработки
- Прогнозирование сроков и трудозатрат
- Определение узких мест и областей для улучшения
- Принятие обоснованных управленческих решений

---

### 16. Тестовое покрытие

**Тестовое покрытие** — это метрика, показывающая, какая часть программного кода была выполнена во время автоматических или ручных тестов.

**Для чего нужно тестовое покрытие:**
- Оценка степени проверенности кода тестами.
- Помогает выявить не протестированные участки программы.
- Повышает качество и надёжность программного продукта.

**Виды тестового покрытия:**
- **Покрытие строк кода (Line coverage):** процент строк, выполненных при тестировании.
- **Покрытие условий (Condition/Branch coverage):** процент логических ветвлений (if, case), которые были выполнены.
- **Покрытие путей (Path coverage):** процент всех возможных путей выполнения кода.
- **Покрытие функций/методов:** процент протестированных функций/методов.

**Как измеряется:**
- Используются специальные инструменты (например, JaCoCo для Java, Coverage.py для Python, Istanbul для JS).
- После запуска тестов формируется отчёт с процентами покрытия.

---

### 17. Тестовый сценарий

**Тестовый сценарий** — это последовательность действий, условий и ожидаемых результатов, предназначенных для проверки одной или нескольких функций программного обеспечения.

**Основные элементы тестового сценария:**
- **Идентификатор** — уникальный номер или название сценария.
- **Название** — краткое описание того, что проверяет сценарий.
- **Предусловия** — состояние системы или необходимые действия, которые должны быть выполнены перед началом теста.
- **Шаги выполнения** — последовательные действия, которые должен выполнить тестировщик.
- **Ожидаемый результат** — что должно произойти после каждого шага или по завершении сценария.
- **Фактический результат** (заполняется после теста) — что реально произошло при выполнении сценария.
- **Статус** — результат теста (пройден/не пройден).

**Пример тестового сценария для интернет-магазина:**

1. **ID:** TC-001  
2. **Название:** Добавление товара в корзину  
3. **Предусловия:** Пользователь авторизован, открыт каталог товаров  
4. **Шаги:**
   1. Выбрать товар из каталога  
   2. Нажать кнопку "Добавить в корзину"  
   3. Открыть корзину  
5. **Ожидаемый результат:**  
   Выбранный товар отображается в корзине с верным названием и ценой.

---

### 18. Тестовый пакет

**Тестовый пакет** — это совокупность взаимосвязанных тестовых сценариев и/или тестовых случаев, объединённых по определённому признаку (например, по функциональности, модулю, типу тестирования) и предназначенных для совместного выполнения.

**Основные характеристики тестового пакета:**
- Включает несколько тестовых сценариев или тест-кейсов, связанных общей целью.
- Позволяет систематизировать тестирование, охватывать определённую часть функционала или аспект системы.
- Может быть настроен для автоматического или ручного запуска (например, в системах CI/CD).

**Структура тестового пакета:**
- **Название пакета**
- **Описание** (какую часть системы покрывает, цель)
- **Список входящих тестовых сценариев/кейсов**
- **Условия выполнения** (например, последовательность или параллельность запуска)
- **Ожидаемый результат** (общий для всего пакета или для каждого теста)

**Пример:**  
Тестовый пакет «Авторизация» может включать сценарии:  
- Вход с правильными данными  
- Вход с неверным паролем  
- Вход с заблокированным пользователем

---

### 19. Анализ спецификаций

**Анализ спецификаций** — это процесс проверки, оценки и улучшения документа с требованиями (спецификации) перед началом разработки.

**Основные задачи анализа спецификаций:**
- Проверка полноты: все ли требования учтены, нет ли пропусков.
- Оценка однозначности формулировок: нет ли двусмысленностей, разночтений.
- Проверка согласованности: нет ли противоречий между требованиями.
- Оценка реализуемости: возможно ли выполнить требования с имеющимися ресурсами и технологиями.
- Проверка тестируемости: можно ли проверить выполнение каждого требования.
- Анализ прослеживаемости: можно ли отследить каждое требование от постановки до реализации и тестирования.
- Уточнение требований: выявление скрытых, неформализованных или избыточных требований.

**Методы анализа спецификаций:**
- **Рецензирование (peer review):** коллективная проверка документа командой.
- **Чек-листы:** использование списков критериев качества требований.
- **Прототипирование:** создание прототипов для проверки понимания требований.
- **Трассировка требований (traceability):** построение связей между требованиями, задачами и тестами.
- **Анализ на соответствие стандартам (например, IEEE, ГОСТ).**

---

### 20. Верификация и аттестация программного обеспечения

**Верификация и аттестация программного обеспечения** — это процессы, направленные на подтверждение качества и соответствия программного продукта установленным требованиям и стандартам.

### Верификация ПО

**Верификация** (от англ. verification) — это процесс проверки, правильно ли реализована система с точки зрения внутренних требований и спецификаций.  
**Вопрос:** "Делаем ли мы продукт правильно?"

**Цели верификации:**
- Убедиться, что продукт соответствует спецификации.
- Найти дефекты на ранних этапах.
- Предотвратить ошибки в реализации.

**Методы верификации:**
- Рецензирование (review) и инспекции документации и кода.
- Анализ и статическое тестирование (без запуска программы).
- Моделирование, трассировка требований.
- Анализ соответствия стандартам.

### Аттестация ПО

**Аттестация** (или валидация, от англ. validation) — это процесс подтверждения, что конечный продукт соответствует ожиданиям и нуждам пользователя, а также установленным стандартам и нормативам.  
**Вопрос:** "Делаем ли мы правильный продукт?"

**Цели аттестации:**
- Убедиться, что ПО решает задачи пользователя.
- Подтвердить пригодность к эксплуатации.
- Получить официальное разрешение на внедрение в промышленную эксплуатацию.

**Методы аттестации:**
- Функциональное и приёмочное тестирование.
- Проведение испытаний по утверждённым методикам.
- Эксплуатационные испытания у заказчика.
- Оформление протоколов испытаний и заключений.

**Различия:**
- **Верификация:** фокус на соответствии внутренним требованиям и спецификациям.
- **Аттестация:** фокус на соответствии ожиданиям пользователя и внешним стандартам.

---

### 21. Жизненный цикл программного обеспечения. Краткая характеристика каждого типа

**1. Сбор требований**  
Определяем, что нужно сделать — общаемся с заказчиком, записываем, какие задачи должна решать программа.

**2. Проектирование**  
Планируем, как это будет работать — рисуем схемы, придумываем структуру программы.

**3. Реализация (разработка)**  
Пишем саму программу — программисты создают код.

**4. Тестирование**  
Проверяем, правильно ли работает программа, ищем ошибки.

**5. Внедрение (выпуск)**  
Устанавливаем программу пользователям, запускаем «в жизнь».

**6. Сопровождение (поддержка)**  
Исправляем найденные ошибки, добавляем новые функции по мере необходимости.

**Пример:**  
Сделать интернет-магазин:  
1. Узнали, что хочет клиент (например, корзину, оплату).  
2. Нарисовали, как это будет выглядеть.  
3. Написали сайт.  
4. Проверили, чтобы всё работало.  
5. Запустили для покупателей.  
6. Исправляем баги, дорабатываем.

Если нужно совсем коротко:  
**1. Что делать? → 2. Как делать? → 3. Сделать → 4. Проверить → 5. Запустить → 6. Поддерживать**

### 22. Разработка пользовательских интерфейсов. Типы пользовательских интерфейсов и этапы их разработки
**Пользовательский интерфейс (UI)** — это система средств, с помощью которой пользователь взаимодействует с программой или устройством.

**Типы пользовательских интерфейсов:**
- **Графический интерфейс (GUI):** визуальные элементы — окна, кнопки, меню (например, Windows, мобильные приложения).
- **Командный интерфейс (CLI):** взаимодействие через текстовые команды (терминал Linux, командная строка Windows).
- **Голосовой интерфейс:** управление с помощью голосовых команд (Siri, Alexa).
- **Жестовый интерфейс:** взаимодействие с помощью жестов и касаний (сенсорные экраны, VR).
- **Меню-интерфейс:** выбор действий через меню (банкоматы, терминалы).

**Этапы разработки интерфейса:**
1. **Анализ требований:** изучение задач и потребностей пользователей, определение целевой аудитории.
2. **Проектирование:** выбор типа интерфейса, продумывание структуры и сценариев использования.
3. **Прототипирование:** создание эскизов или макетов интерфейса.
4. **Тестирование прототипа:** проверка удобства и понятности интерфейса с помощью пользователей.
5. **Реализация:** программирование и оформление интерфейса.
6. **Тестирование и доработка:** выявление ошибок, внесение улучшений по обратной связи.

---

### 23. Техническое задание. Разделы, входящие в техническое задание
**Техническое задание (ТЗ)** — это официальный документ, в котором фиксируются требования к разрабатываемому программному обеспечению или системе. ТЗ служит основой для последующей работы команды разработчиков, тестировщиков и заказчика.

**Основные разделы технического задания:**
- **Введение** — описание целей и задач проекта, назначение системы.
- **Общие сведения о системе** — краткое описание, область применения, основные функции.
- **Требования к функционалу** — детальное описание всех функций, которые должна выполнять система.
- **Требования к интерфейсу** — описание внешнего вида, взаимодействия с пользователем, интеграции с другими системами.
- **Требования к производительности** — скорость отклика, поддержка одновременных пользователей и т.д.
- **Требования к надёжности и безопасности** — меры по обеспечению отказоустойчивости, защита данных.
- **Требования к совместимости** — поддерживаемые операционные системы, взаимодействие с внешними сервисами.
- **Ограничения и допущения** — ограничения по технологиям, ресурсам, срокам и т.д.
- **Критерии приёмки** — условия, при которых работа будет считаться выполненной.
- **Приложения** — схемы, макеты, дополнительные материалы.

**Зачем нужен этот документ:**  
Техническое задание помогает согласовать ожидания между заказчиком и исполнителем, минимизировать недопонимание и служит основой для контроля выполнения работ.

---

### 24. Использование языка UML при проектировании сложных программных систем

**UML (Unified Modeling Language)** — это стандартный язык для визуального моделирования и документирования архитектуры сложных программных систем.

**Зачем используется UML:**
- Позволяет создавать наглядные схемы, которые упрощают понимание структуры и поведения системы.
- Обеспечивает единый язык общения между разработчиками, аналитиками и заказчиками.
- Помогает выявить ошибки на ранних этапах проектирования.

**Основные виды UML-диаграмм:**
- **Диаграмма классов** — показывает структуры данных, связи между классами, их свойства и методы.
- **Диаграмма вариантов использования (use case)** — описывает, какие функции доступны пользователям системы.
- **Диаграмма последовательности** — отражает порядок взаимодействия объектов во времени.
- **Диаграмма компонентов** — отображает модули системы и их взаимодействие.
- **Диаграмма состояний** — описывает изменения состояний объектов под воздействием событий.
- **Диаграмма деятельности** — моделирует бизнес-процессы и алгоритмы.

**Применение UML при проектировании:**
1. Анализ и описание требований к системе.
2. Визуализация архитектуры и ключевых компонентов.
3. Проектирование структуры данных, бизнес-логики и взаимодействий.
4. Документирование решений для дальнейшей поддержки и развития системы.

---

### 25. Диаграмма вариантов использования, её назначение. Правила построения диаграммы вариантов использования

**Диаграмма вариантов использования (Use Case Diagram)** — это один из видов UML-диаграмм, который отображает, какие функции (сценарии использования) предоставляет система внешним пользователям (акторам). Она помогает понять, что должно делать программное обеспечение с точки зрения пользователя.

**Назначение диаграммы вариантов использования:**
- Показывает основные функции системы и взаимодействие пользователей с этими функциями.
- Помогает определить границы системы (что входит в систему, а что находится вне её).
- Служит основой для дальнейшей детализации требований и проектирования.

**Основные элементы диаграммы:**
- **Акторы** — внешние пользователи или другие системы, взаимодействующие с системой (например, пользователь, администратор).
- **Варианты использования** — отдельные функции или задачи, которые выполняет система по запросу актора (например, «Оформить заказ», «Войти в систему»).
- **Связи** — линии, показывающие, какой актор может использовать какой вариант.
- **Границы системы** — прямоугольник, в котором расположены все варианты использования, чтобы показать, что входит в систему.

**Правила построения диаграммы вариантов использования:**
- Определить всех акторов, которые будут взаимодействовать с системой.
- Для каждого актора описать основные варианты использования (сценарии), которые для него доступны.
- Изобразить акторов и варианты использования в виде овалов и человечков, соединяя их линиями.
- Все варианты использования размещать внутри прямоугольника, обозначающего систему.
- Использовать дополнительные отношения (например, «include» — включение, «extend» — расширение) для уточнения связей между вариантами использования.
- Диаграмма должна быть простой и наглядной, чтобы легко воспринималась всеми участниками проекта.

---

### 26. Понятие класса и объекта. Атрибут и операция
**Класс** — это шаблон (описание), по которому создаются объекты. Класс определяет, какие характеристики (атрибуты) и действия (операции) будут у объектов этого типа.

**Объект** — это конкретный экземпляр класса, обладающий всеми его свойствами и возможностями. Один и тот же класс может использоваться для создания множества объектов, каждый из которых может иметь свои уникальные значения атрибутов.

**Атрибут** — это характеристика или свойство, которое описывает объект (например, имя, возраст, цвет).

**Операция** (или метод) — это действие, которое может выполнять объект, или функция, связанная с классом (например, «вывести имя», «изменить значение»).

**Пример:**
- Класс: Автомобиль  
  Атрибуты: цвет, марка, скорость  
  Операции: ехать, остановиться, сигналить

- Объект: красный автомобиль марки Toyota, движется со скоростью 60 км/ч

---

### 27. Диаграммы потоков данных. Основное назначение

**Диаграммы потоков данных (DFD, Data Flow Diagram)** — это графический способ описания того, как данные перемещаются внутри информационной системы.

**Основное назначение DFD:**
- Отображать, как информация поступает, обрабатывается, хранится и уходит из системы.
- Помогать понять структуру процессов и взаимосвязи между ними.
- Используются для анализа и проектирования программных и бизнес-систем на ранних этапах разработки.

**Основные элементы диаграммы:**
- **Процессы** — действия или преобразования данных (например, "Обработка заказа").
- **Потоки данных** — линии, показывающие движение данных между элементами.
- **Хранилища данных** — места, где данные сохраняются (например, база данных).
- **Внешние сущности** — объекты или пользователи, взаимодействующие с системой извне.

**Зачем нужны DFD:**
- Позволяют наглядно увидеть, как устроена система и как она обрабатывает информацию.
- Помогают выявить дублирование, недостатки, «узкие места» и улучшить структуру процессов до написания кода.
- Улучшают взаимопонимание между заказчиком, аналитиками и разработчиками.

---

### 28. Основные принципы структурной методологии. Особенности структурных диаграмм

**Структурная методология** — это подход к анализу и проектированию программных систем, основанный на разбиении сложной системы на более простые, взаимосвязанные части (модули). Главная цель — упростить разработку, сделать систему более понятной, управляемой и удобной для поддержки.

**Основные принципы структурной методологии:**
- **Декомпозиция:** Разделение сложной системы на отдельные модули или подсистемы, каждая из которых решает свою задачу.
- **Иерархия:** Организация модулей в виде дерева, где верхний уровень — это вся система, а нижние — отдельные функции или процессы.
- **Модульность:** Каждый модуль максимально автономен и выполняет одну определённую функцию.
- **Связность (cohesion):** Внутри модуля все элементы тесно связаны между собой и слабо связаны с другими модулями.
- **Минимизация связей (loose coupling):** Модули должны взаимодействовать между собой через чётко определённые интерфейсы, чтобы изменение одного не требовало изменений в других.
- **Абстракция:** Сокрытие деталей реализации модуля, открытие только необходимого интерфейса.

**Особенности структурных диаграмм:**
- **Структурные диаграммы** визуализируют архитектуру системы, показывают её компоненты и связи между ними.
- Основные виды структурных диаграмм:
  - **Диаграмма потоков данных (DFD):** показывает, как данные перемещаются между процессами и хранилищами.
  - **Диаграмма декомпозиции (иерархическая диаграмма):** отражает разбиение системы на модули и подмодули.
  - **Диаграмма структур программ (структурная блок-схема):** описывает логику работы программных модулей через последовательность, ветвления и циклы.
- Структурные диаграммы просты для понимания и позволяют анализировать систему на разных уровнях детализации.
- Используются для документирования архитектуры, облегчения командной работы, выявления дублирований и слабых мест.

--- 

### 29. Модульное программирование (определение). Цели модульного программирования. Достоинства модульного программирования

**Модульное программирование** — это подход к разработке программного обеспечения, при котором программа разбивается на независимые блоки (модули). Каждый модуль отвечает за выполнение определённой задачи и может разрабатываться, тестироваться и модифицироваться отдельно от остальных частей программы.

**Цели модульного программирования:**
- Упростить разработку и сопровождение программ за счёт разбиения на отдельные части.
- Повысить повторное использование кода (один и тот же модуль можно применять в разных проектах).
- Обеспечить независимость между разными частями программы.
- Упростить тестирование, отладку и локализацию ошибок.

**Достоинства модульного программирования:**
- **Повышается читаемость и понятность кода** — программа становится структурированной и логичной.
- **Упрощается командная работа** — разные разработчики могут работать над разными модулями параллельно.
- **Лёгкая модификация и расширяемость** — изменение одного модуля не затрагивает остальные (при правильно спроектированных интерфейсах).
- **Повторное использование** — модули можно использовать в других проектах без изменений.
- **Упрощается тестирование** — можно проверять работу каждого модуля отдельно, что облегчает поиск и исправление ошибок.

**Вывод:**  
Модульное программирование делает разработку крупных и сложных программных систем более эффективной, надёжной и удобной для сопровождения.

---

### 30. Объектно-ориентированное программирование. Основные понятия: объект, свойство объекта, метод обработки, событие, класс объектов. 
## Метод объектно-ориентированной декомпозиции, метод абстрактных типов данных, метод пересылки сообщений

**Объектно-ориентированное программирование (ООП)** — это парадигма программирования, в которой основными сущностями являются объекты, объединяющие данные и методы их обработки.

**Основные понятия ООП:**
- **Объект** — конкретный экземпляр класса, обладающий состоянием и поведением. Например, объект «автомобиль» может иметь свойства и методы, описанные в классе «Автомобиль».
- **Свойство объекта (атрибут, поле)** — характеристика объекта, определяющая его состояние. Например, цвет, скорость, модель.
- **Метод обработки (метод)** — функция или процедура, определяющая, что умеет делать объект. Например, методы «поехать», «остановиться».
- **Событие** — действие, происходящее с объектом или вызванное внешним воздействием, на которое объект может реагировать. Например, событие «нажатие кнопки».
- **Класс объектов (класс)** — шаблон (описание), по которому создаются объекты. Класс определяет набор свойств и методов для объектов этого типа.

### Методы объектно-ориентированного анализа и проектирования

**Метод объектно-ориентированной декомпозиции:**
- Система разбивается на объекты, которые моделируют реальные или абстрактные сущности предметной области.
- Каждый объект сам отвечает за хранение своих данных и реализацию поведения.
- Взаимодействие между объектами строится через вызовы методов, что облегчает повторное использование, расширяемость и поддержку системы.

**Метод абстрактных типов данных:**
- Описывает не только структуру данных, но и операции, которые можно выполнять с этими данными.
- Абстрактный тип данных скрывает детали реализации и предоставляет только интерфейс (набор доступных операций).
- Пример: «Стек» — есть операции push/pop, но не важно, как стек реализован внутри.

**Метод пересылки сообщений:**
- Объекты взаимодействуют между собой с помощью сообщений (вызовов методов).
- Каждый объект принимает сообщения и выполняет соответствующие действия.
- Такой подход обеспечивает слабую связанность и гибкость архитектуры: объекты не знают внутреннего устройства друг друга, а только интерфейс.

**Вывод:**  
ООП позволяет создавать сложные, гибкие и масштабируемые системы за счёт моделирования предметной области через объекты, их свойства, методы и событийные взаимодействия. Методы ООП — декомпозиция на объекты, использование абстрактных типов и пересылка сообщений — обеспечивают удобную структуру и поддержку кода.

---

### 31. Надёжность программного изделия. Работоспособность программного изделия. Основные количественные показатели надёжности программного изделия

**Надёжность программного изделия** — это способность программы выполнять требуемые функции в течение заданного времени и при определённых условиях, без сбоев и ошибок. Надёжное программное обеспечение минимизирует вероятность отказа, обеспечивает устойчивую работу и предсказуемое поведение в штатных и нештатных ситуациях.

**Работоспособность программного изделия** — это состояние программы, при котором она способна выполнять все свои функции корректно и полностью, в соответствии с требованиями. Работоспособность — это признак того, что программное изделие функционирует как ожидается на данный момент времени.

**Основные количественные показатели надёжности программного изделия:**
- **Вероятность безотказной работы (P):** вероятность того, что программа будет функционировать без отказов в течение определённого времени.
- **Интенсивность отказов (λ):** среднее число отказов программы за единицу времени.
- **Среднее время безотказной работы (MTBF, Mean Time Between Failures):** среднее время между двумя последовательными отказами.
- **Среднее время восстановления (MTTR, Mean Time To Repair):** среднее время, необходимое для восстановления работоспособности после сбоя.
- **Доступность (Availability):** отношение времени, когда система работоспособна, ко всему времени эксплуатации. Обычно выражается в процентах.

**Зачем нужны эти показатели:**  
Они позволяют объективно оценивать качество программного продукта, сравнивать альтернативные решения, выявлять и устранять слабые места, а также обосновывать требования к надёжности при разработке и эксплуатации ПО.

**Вывод:**  
Надёжность и работоспособность — это важнейшие свойства программного обеспечения, непосредственно влияющие на его качество, пользовательский опыт и успех проекта. Количественные показатели надёжности используются для оценки, контроля и повышения устойчивости программных систем.

---

### 32. Определение тестирования и отладки. Особенности и объекты тестирования. Автономное и комплексное тестирование

**Тестирование** — это процесс проверки программного обеспечения с целью выявления ошибок, несоответствий требованиям и обеспечения качества продукта. Тестирование позволяет убедиться, что программа работает правильно во всех предусмотренных сценариях.

**Отладка** — процесс поиска, анализа и исправления ошибок в программном коде. Обычно отладка начинается после обнаружения дефектов в ходе тестирования.

**Особенности тестирования:**
- Выполняется как вручную, так и с помощью автоматизированных средств.
- Не гарантирует полного отсутствия ошибок, а лишь повышает уверенность в качестве программы.
- Использует различные методы и уровни тестирования в зависимости от этапа разработки.

**Объекты тестирования:**
- **Модули и функции** — отдельные части программы.
- **Компоненты и подсистемы** — группы связанных модулей.
- **Вся система в целом** — интегрированное программное изделие.
- **Интерфейсы** — точки взаимодействия между модулями и внешними системами.

**Автономное (модульное, индивидуальное) тестирование:**
- Проверяет отдельные модули или компоненты в изоляции от остальных частей системы.
- Позволяет выявлять ошибки на раннем этапе и упрощает их локализацию.
- Часто реализуется с помощью юнит-тестов.

**Комплексное тестирование:**
- Проверяет работу всей системы или её крупных частей в целом.
- Оценивает взаимодействие между модулями, корректность интеграции и выполнение бизнес-процессов.
- Включает интеграционное и системное тестирование.

**Вывод:**  
Тестирование и отладка — важные этапы разработки, направленные на повышение качества ПО. Автономное тестирование позволяет быстро находить и устранять ошибки в отдельных модулях, а комплексное — обеспечивает проверку корректности работы всей системы в целом.

---

### 33. Управление разработкой программных средств. Средства управления проектами. Основная цель управления жизненным циклом программных средств

**Управление разработкой программных средств** — это комплекс мероприятий, направленных на эффективное планирование, организацию, контроль и координацию процессов создания программного обеспечения (ПО). Оно включает в себя управление ресурсами, сроками, качеством, рисками, коммуникациями и бюджетом проекта.

#### Средства управления проектами

Для успешного управления проектом по разработке ПО используются различные **средства управления проектами (Project Management Tools)**, которые позволяют автоматизировать и упростить процессы:

- **Jira, Trello, Asana, Redmine** — для постановки и отслеживания задач, ведения бэклога, учета времени и контроля статуса задач.
- **Microsoft Project** — для составления графиков, диаграмм Ганта, управления ресурсами.
- **Confluence, Notion, Google Workspace** — для совместной работы, хранения и обмена документацией.
- **GitHub Projects, GitLab Issues** — для интеграции управления задачами с системами контроля версий.
- **CI/CD-системы** (Jenkins, GitHub Actions) — для автоматизации сборки, тестирования и развертывания.

#### Основная цель управления жизненным циклом программных средств

**Жизненный цикл программного средства** — это последовательность стадий, через которые проходит ПО с момента возникновения идеи до вывода из эксплуатации (планирование, анализ требований, проектирование, разработка, тестирование, внедрение, сопровождение и поддержка).

**Основная цель управления жизненным циклом ПО:**
- Обеспечить эффективное и качественное создание, внедрение и сопровождение программного продукта на всех этапах его существования.

Это достигается за счет:
- Минимизации рисков и ошибок на каждом этапе.
- Рационального использования ресурсов (времени, денег, кадров).
- Контроля выполнения сроков и бюджета.
- Гибкой адаптации к изменениям требований.
- Повышения качества и удовлетворенности заказчика.

**Вывод:**  
Управление разработкой и жизненным циклом программных средств необходимо для того, чтобы ПО разрабатывалось эффективно, соответствовало требованиям, было качественным и устойчивым, а процесс его создания был прозрачным и управляемым.

---

### 34. Инструментальные средства разработки программ. Инструментальные среды программирования. Средства автоматизации разработки программ (CASE-средства). Интегрированные среды

**Инструментальные средства разработки программ** — это совокупность программных инструментов, используемых на всех этапах создания программного обеспечения: от проектирования и написания кода до тестирования и сопровождения.

#### Инструментальные среды программирования

**Инструментальная среда программирования** — это комплекс программных средств, которые обеспечивают удобное написание, запуск и отладку программ. В такие среды обычно входят:
- Текстовые редакторы исходного кода (например, Visual Studio Code, Sublime Text)
- Компиляторы и интерпретаторы
- Отладчики (debugger)
- Средства для управления проектами и версиями кода (например, Git)

#### Средства автоматизации разработки программ (CASE-средства)

**CASE-средства** (Computer-Aided Software Engineering) — это средства автоматизации процессов проектирования, разработки и сопровождения программного обеспечения.  
Они предоставляют следующие возможности:
- Графическое моделирование систем (UML-диаграммы, ER-диаграммы)
- Генерация кода на основе моделей
- Документирование и управление требованиями
- Анализ, рефакторинг и тестирование кода

**Примеры CASE-средств:**  
Enterprise Architect, IBM Rational Rose, StarUML.

#### Интегрированные среды разработки (IDE)

**Интегрированная среда разработки (IDE, Integrated Development Environment)** — это программный комплекс, объединяющий в себе большинство инструментов, необходимых для эффективной разработки программного обеспечения:
- Редактор кода
- Компилятор/интерпретатор
- Отладчик
- Средства автоматического тестирования
- Система контроля версий
- Подсветка синтаксиса, автодополнение кода, рефакторинг

**Примеры IDE:**  
IntelliJ IDEA, Visual Studio, PyCharm, Eclipse, NetBeans.

**Вывод:**  
Инструментальные средства разработки, интегрированные среды и CASE-средства значительно повышают эффективность и качество процесса создания программного обеспечения, автоматизируя рутинные задачи и обеспечивая поддержку на всех этапах жизненного цикла ПО.

---

### 35. Оценка качества программного обеспечения. Методы оценки свойств программного обеспечения

**Оценка качества программного обеспечения (ПО)** — это процесс определения степени соответствия программного продукта установленным требованиям, ожиданиям пользователей и стандартам качества. Качество ПО определяет, насколько программа надёжна, удобна, функциональна, безопасна и пригодна для сопровождения.

### Основные свойства качества программного обеспечения

Классические критерии (по стандарту ISO/IEC 25010):

- **Функциональная пригодность** — насколько ПО выполняет требуемые функции.
- **Надёжность** — устойчивость и безотказность работы в течение времени.
- **Удобство использования (юзабилити)** — простота и интуитивность интерфейса для пользователя.
- **Производительность** — быстродействие и эффективное использование ресурсов.
- **Безопасность** — защита данных и предотвращение несанкционированного доступа.
- **Совместимость** — способность работать в разных средах, с разными системами.
- **Сопровождаемость** — лёгкость внесения изменений, исправления ошибок, модернизации.
- **Переносимость** — возможность работы на различных платформах.

### Методы оценки свойств программного обеспечения

1. **Аналитические методы**
   - Анализ документации, кода, архитектуры на соответствие стандартам и best practices.
   - Экспертная оценка — привлечение специалистов для анализа и вынесения суждения о качестве.

2. **Эмпирические методы**
   - **Тестирование** — проведение различных видов тестов (unit, integration, system, acceptance) для выявления ошибок и оценки соответствия требованиям.
   - **Испытания в реальных условиях эксплуатации** — проверка ПО в условиях, максимально приближённых к рабочим.

3. **Методы количественной оценки**
   - Использование метрик качества ПО:
     - Количество дефектов на тысячу строк кода (Defect Density)
     - Покрытие кода тестами (Code Coverage)
     - Время на исправление дефекта (MTTR)
     - Среднее время безотказной работы (MTBF)
     - Время отклика/производительность

4. **Методы опроса и анкетирования**
   - Сбор отзывов пользователей и заказчиков о качестве работы, удобстве, функциональности ПО.

5. **Автоматизированные средства анализа**
   - Статический анализ кода (линтеры, анализаторы стиля, средства поиска уязвимостей).
   - Динамический анализ (профилировщики, анализаторы производительности).

**Вывод:**  
Оценка качества программного обеспечения предполагает системный подход, сочетающий анализ, тестирование, применение метрик и сбор обратной связи. Это позволяет выявить сильные и слабые стороны продукта, повысить его надёжность, удобство и соответствие ожиданиям пользователей.

---

### 36. Внедрение программного комплекса. Подготовка тестовых данных. Анализ результатов испытаний

1. **Внедрение программного комплекса:**

   * Устанавливается программное обеспечение на рабочие компьютеры или сервер;
   * Настраивается база данных и соединение с интерфейсом;
   * Проводится обучение пользователей и первичная настройка системы;
   * Запускается тестовая эксплуатация.

2. **Подготовка тестовых данных:**

   * Создаются пробные записи (например, преподаватели, дисциплины, кафедры);
   * Данные заносятся вручную или с помощью SQL-запросов;
   * Используются для проверки всех функций системы.

3. **Анализ результатов испытаний:**

   * Проверяется функциональность всех модулей;
   * Тестируется защита и доступ по ролям (например, обычный пользователь не должен попасть в админ-панель);
   * Оценивается стабильность и скорость работы системы;
   * По итогам устраняются ошибки и дорабатываются функции;
   * После успешного тестирования система вводится в постоянную эксплуатацию.