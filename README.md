### 1. Понятия требований, классификация
Вот более развернутый, но всё ещё компактный ответ для экзамена:

**Требования** — это условия или возможности, которым должна соответствовать система для удовлетворения нужд пользователей и заказчиков.

**Классификация требований:**
1. **По содержанию:**
   - **Функциональные требования** — описывают, какие функции должна выполнять система (например, «система должна хранить данные о пользователях»).
   - **Нефункциональные требования** — определяют качественные характеристики системы: производительность, надёжность, безопасность, удобство использования и др.
2. **По уровню:**
   - **Бизнес-требования** — цели организации, которых должна достичь система.
   - **Пользовательские требования** — задачи, которые пользователь сможет решать с помощью системы.
   - **Системные требования** — детализированные требования к самой системе, её компонентам и взаимодействию.
3. **По обязательности:**
   - **Обязательные** (must have) — без них система не будет функционировать.
   - **Желательные** (nice to have) — улучшают работу, но не критичны.

**Пример:**  
Функциональное требование: «Система должна отправлять письма пользователям».  
Нефункциональное: «Время отклика не должно превышать 2 секунд».

---

### 2. Уровни требований

**Уровни требований** — это различные ступени детализации описания того, что должна обеспечивать разрабатываемая система.

**Основные уровни требований:**

1. **Бизнес-требования**  
   - Описывают цели и задачи организации, которых должна достичь система.  
   - Формулируются на уровне бизнеса.  
   - Пример: "Увеличить прибыль компании за счет автоматизации продаж."
2. **Пользовательские требования**  
   - Показывают, что пользователь сможет делать с помощью системы.  
   - Задают поведение системы с точки зрения пользователя, часто оформляются как сценарии использования.  
   - Пример: "Пользователь может просматривать и редактировать свой профиль."
3. **Системные требования**  
   - Подробно описывают функции и характеристики системы, необходимые для реализации пользовательских требований.  
   - Являются основой для проектирования и тестирования.  
   - Пример: "Система должна хранить данные о пользователях в защищённой базе данных."

**Структура:**  
Бизнес-требования → Пользовательские требования → Системные требования

---

### 3. Методологии и стандарты, регламентирующие работу с требованиями
**Методологии и стандарты, регламентирующие работу с требованиями** — это формализованные подходы и документы, которые определяют процессы выявления, документирования, анализа и управления требованиями к системе.

**Основные методологии:**
- **Waterfall (Каскадная модель):** требования фиксируются на начальном этапе и практически не изменяются в ходе проекта.
- **Agile (Гибкие методологии):** требования формируются и уточняются итеративно, допускаются изменения на любом этапе (например, Scrum, Kanban).
- **RUP (Rational Unified Process):** требования уточняются поэтапно, акцент на управление изменениями.

**Основные стандарты:**
- **IEEE 830-1998:** стандарт по описанию требований к программному обеспечению (SRS — Software Requirements Specification).
- **ISO/IEC/IEEE 29148:** международный стандарт, объединяющий лучшие практики по управлению требованиями.
- **BABOK (Business Analysis Body of Knowledge):** свод знаний по бизнес-анализу, описывает процессы работы с требованиями.
- **ГОСТ 34.602-89 (для России):** стандарт по проектированию автоматизированных систем, включая работу с требованиями.

---

### 4. Современные принципы и методы разработки программных приложений

**Современные принципы и методы разработки программных приложений** — это подходы и правила, которые используются для эффективного и качественного создания программного обеспечения.


**Основные принципы:**
- **Модульность** — система строится из отдельных, независимых компонентов.
- **Повторное использование (reuse)** — использование существующих модулей или библиотек.
- **Гибкость и адаптивность** — возможность быстро вносить изменения в проект.
- **Ориентация на пользователя** — разработка ведётся с учетом удобства и потребностей конечного пользователя.
- **Автоматизация тестирования и сборки** — внедрение CI/CD, автоматических тестов.

**Современные методы разработки:**
- **Agile (гибкие методологии)** — итеративная разработка с постоянной обратной связью (например, Scrum, Kanban).
- **DevOps** — объединение процессов разработки и эксплуатации, автоматизация развертывания и тестирования.
- **Test-Driven Development (TDD)** — разработка через написание тестов до кода.
- **Continuous Integration/Continuous Delivery (CI/CD)** — непрерывная интеграция и доставка изменений в продукт.
- **Domain-Driven Design (DDD)** — проектирование системы на основе предметной области.

---

### 5. Методы организации работы в команде разработчиков

**Методы организации работы в команде разработчиков** — это подходы и практики, которые помогают эффективно управлять совместной работой над проектом, распределять задачи и достигать целей.

**Основные методы:**

- **Классические методы управления проектами**  
  — Жёсткая иерархия, чёткое распределение ролей и обязанностей (например, водопадная модель/Waterfall).

- **Гибкие (Agile) методологии**  
  — Командная работа организована итерациями, с постоянной обратной связью и адаптацией к изменяющимся требованиям.  
  — Популярные подходы:
    - **Scrum** — работа по спринтам, есть роли Product Owner, Scrum Master, команда разработки, ежедневные стендапы, планирование, ретроспективы.
    - **Kanban** — непрерывное движение задач по доске (визуализация процесса), гибкое распределение работы.
    - **Extreme Programming (XP)** — акцент на тесном взаимодействии, парное программирование, частые релизы.

- **DevOps**  
  — Объединение команд разработки и сопровождения, автоматизация процессов (CI/CD), совместная ответственность за продукт.

- **Матрица ответственности (RASCI, RACI)**  
  — Формализованное распределение ролей: кто отвечает, выполняет, согласует, консультирует и информирует по задачам.

- **Использование инструментов для совместной работы**  
  — Системы управления задачами (Jira, Trello), репозитории кода (GitHub, GitLab), мессенджеры и видеоконференции (Slack, Zoom).

---

### 6. Системы контроля версий

**Системы контроля версий** — это программные инструменты, предназначенные для хранения, отслеживания и управления изменениями в исходном коде или других файлах проекта.

**Основные задачи систем контроля версий:**
- Хранение истории изменений файлов.
- Совместная работа нескольких разработчиков.
- Возможность возврата к предыдущим версиям (откат изменений).
- Разветвление разработки (ветки/branches) и слияние изменений (merge).

**Типы систем контроля версий:**
- **Локальные** — хранят изменения только на одном компьютере (например, RCS).
- **Централизованные** — используют единый сервер для хранения истории (например, SVN, CVS).
- **Распределённые** — каждый участник имеет полную копию репозитория (например, Git, Mercurial).

**Популярные системы:**
- **Git** — самая распространённая, поддерживает распределённую работу, ветвление, используется на GitHub, GitLab, Bitbucket.
- **Subversion (SVN)** — централизованная система, раньше была стандартом для многих проектов.
- **Mercurial** — распределённая система, похожая на Git.

---

### 7. Основные подходы к интегрированию программных модулей

**Основные подходы к интегрированию программных модулей** — это методы, с помощью которых реализуется объединение отдельных частей (модулей) системы в единую рабочую программу.

**Основные подходы:**

- **Big Bang (Большой взрыв):**  
  Все модули разрабатываются отдельно, а затем интегрируются одновременно. Простой, но сложно выявлять ошибки.

- **Поэтапная (инкрементальная) интеграция:**  
  Модули объединяются постепенно, по одному или небольшими группами.  
  Варианты:
    - **Восходящая интеграция (Bottom-Up):** сначала объединяются нижние уровни, затем более высокие.
    - **Нисходящая интеграция (Top-Down):** интеграция начинается с самых верхних модулей и постепенно добавляются нижние.
    - **Смешанная (сэндвич) интеграция:** одновременно интегрируются верхние и нижние уровни, потом соединяются в середине.

- **Непрерывная интеграция (Continuous Integration, CI):**  
  Модули интегрируются автоматически и постоянно после каждого изменения, что позволяет быстро находить и исправлять ошибки.

---

### 8. Стандарты кодирования

**Стандарты кодирования** — это набор правил и рекомендаций, определяющих стиль написания кода, структуру файлов, оформления имен и другие аспекты программирования для обеспечения читаемости, поддержки и единого стиля в команде.

**Зачем нужны стандарты:**
- Повышают читаемость и понятность кода.
- Упрощают совместную работу и сопровождение проекта.
- Помогают избегать типичных ошибок.

**Основные аспекты стандартов:**
- Форматирование кода: отступы, длина строки, пробелы.
- Именование переменных, функций, классов (например, camelCase, snake_case).
- Комментирование и документация.
- Организация файлов и папок.
- Правила для обработки ошибок и исключений.
- Единые соглашения по использованию языковых конструкций и библиотек.

**Примеры стандартов:**
- **PEP 8** для Python.
- **Google Java Style Guide** для Java.
- **Airbnb JavaScript Style Guide** для JavaScript.
- В крупных компаниях часто есть собственные внутренние стандарты.

---

### 9. Описание требований: унифицированный язык моделирования - краткий словарь

**Описание требований: унифицированный язык моделирования (UML) — краткий словарь**

- **UML (Unified Modeling Language)** — унифицированный язык моделирования, стандарт для визуализации, описания и документирования программных систем.

**Основные элементы UML:**

- **Класс (Class)** — описание сущности с атрибутами и методами.
- **Объект (Object)** — экземпляр класса.
- **Атрибут (Attribute)** — свойство или характеристика класса.
- **Операция/метод (Operation/Method)** — действие, выполняемое классом.
- **Ассоциация (Association)** — связь между классами.
- **Агрегация (Aggregation)** — «целое-часть», слабая связь между объектами.
- **Композиция (Composition)** — «жёсткое целое-часть», сильная связь (часть не существует без целого).
- **Наследование (Generalization)** — отношение «родитель-потомок» между классами.
- **Взаимодействие (Interaction)** — обмен сообщениями между объектами.
- **Актор (Actor)** — внешний пользователь или система, взаимодействующая с системой.
- **Прецедент (Use Case)** — сценарий взаимодействия актора с системой.
- **Диаграмма классов (Class Diagram)** — отображает классы и отношения между ними.
- **Диаграмма прецедентов (Use Case Diagram)** — показывает акторов и их сценарии работы с системой.
- **Диаграмма последовательности (Sequence Diagram)** — описывает взаимодействие объектов во времени.
- **Диаграмма деятельности (Activity Diagram)** — моделирует процессы и потоки управления.

---

### 10. Диаграммы UML

**Диаграммы UML** — это графические схемы, применяемые для визуализации структуры, поведения и взаимодействия компонентов программных систем. UML (Unified Modeling Language, унифицированный язык моделирования) стандартизирует формы и обозначения таких диаграмм.


**Основные виды диаграмм UML:**

- **Диаграмма классов (Class Diagram)**  
  — Показывает классы системы, их атрибуты, методы и отношения (наследование, ассоциации, агрегации и композиции).

- **Диаграмма объектов (Object Diagram)**  
  — Отображает конкретные экземпляры классов и связи между ними на определённый момент времени.

- **Диаграмма прецедентов (Use Case Diagram)**  
  — Иллюстрирует взаимодействие акторов (пользователей или внешних систем) с системой через сценарии (use cases).

- **Диаграмма последовательности (Sequence Diagram)**  
  — Показывает порядок обмена сообщениями между объектами для выполнения определённого сценария.

- **Диаграмма деятельности (Activity Diagram)**  
  — Моделирует логику бизнес-процессов или алгоритмов, отображая последовательность действий и переходов.

- **Диаграмма состояний (State Machine Diagram)**  
  — Описывает состояния объекта и переходы между ними в ответ на события.

- **Диаграмма компонентов (Component Diagram)**  
  — Демонстрирует физические компоненты системы и их взаимосвязи.

- **Диаграмма развертывания (Deployment Diagram)**  
  — Показывает, как программные компоненты размещаются на оборудовании (узлах).

---

### 11. Описание и оформление требований (спецификация)

**Описание и оформление требований (спецификация)** — это процесс формализации требований к программному продукту в виде единого документа, который служит основой для разработки, тестирования и приёмки системы.

**Основные принципы описания требований:**
- Требования должны быть однозначными, полными, проверяемыми, реализуемыми и согласованными.
- Формулировки должны быть максимально точными, избегать двусмысленностей и субъективных оценок (“быстро”, “удобно”, “лучше”).

**Структура спецификации требований (на примере SRS — Software Requirements Specification):**
1. **Введение**
   - Цель документа
   - Область применения
   - Определения и сокращения
2. **Общее описание**
   - Перечень функций системы
   - Пользовательские характеристики
   - Ограничения и допущения
3. **Функциональные требования**
   - Описание функций системы, сценарии использования, реакции на события
4. **Нефункциональные требования**
   - Требования к производительности, безопасности, интерфейсам, совместимости и т.д.
5. **Требования к внешним интерфейсам**
   - Взаимодействие с другими системами и пользователями
6. **Критерии приёмки**
   - Условия, при которых работа будет считаться завершённой

**Оформление:**
- Использование шаблонов (например, IEEE 830, ГОСТ 34.602-89).
- Структурированное изложение (разделы, заголовки, списки).
- Таблицы, диаграммы UML для наглядности.
- Пронумерованные требования для удобства ссылок и отслеживания изменений.

---

### 12. Анализ требований и стратегии выбора решения

**Анализ требований и стратегии выбора решения** — это этапы разработки, на которых проводится оценка собранных требований и определяются подходящие способы их реализации.

**Анализ требований:**
- Включает изучение, уточнение, классификацию и приоритезацию требований.
- Проверяется полнота, согласованность, реализуемость, однозначность и тестируемость требований.
- Выявляются противоречия, дубли и пробелы.
- Формируется модель требований (диаграммы, сценарии, прототипы).

**Стратегии выбора решения:**
- **Сравнение альтернатив**: рассматриваются различные варианты реализации, оцениваются плюсы и минусы каждого (например, разные архитектуры, платформы, технологии).
- **Критерии выбора**: стоимость, сроки, риски, ресурсы, совместимость, масштабируемость, поддержка.
- **Прототипирование**: создание быстрых прототипов для проверки ключевых идей или технической осуществимости.
- **SWOT-анализ**: анализ сильных/слабых сторон, возможностей и угроз для каждого варианта.
- **Коллективное обсуждение**: проведение совещаний, мозговых штурмов, экспертных оценок.
- **Документирование решения**: выбранный вариант фиксируется и согласуется со всеми заинтересованными сторонами.

---

### 13. Цели и задачи, и виды тестирования

**Цели и задачи тестирования:**  
Тестирование — это процесс проверки программного обеспечения с целью выявления ошибок, повышения качества и подтверждения соответствия требованиям.

**Основные цели тестирования:**
- Обнаружение ошибок и дефектов до передачи продукта пользователю.
- Проверка соответствия ПО заявленным требованиям и ожиданиям заказчика.
- Повышение качества продукта (надёжность, производительность, удобство).
- Минимизация рисков, связанных с выпуском дефектного продукта.

**Задачи тестирования:**
- Разработка тестовых сценариев и данных.
- Проведение различных видов тестирования.
- Документирование обнаруженных дефектов.
- Анализ результатов тестирования и подготовка отчётов.
- Проверка исправлений и регрессий.

**Виды тестирования:**

1. **По уровню:**
   - **Модульное (Unit testing):** тестируются отдельные функции/модули.
   - **Интеграционное (Integration testing):** проверяется взаимодействие модулей между собой.
   - **Системное (System testing):** тестируется вся система в целом.
   - **Приёмочное (Acceptance testing):** проводится заказчиком для проверки готовности системы к эксплуатации.

2. **По степени автоматизации:**
   - **Ручное (Manual testing):** тестировщик выполняет тесты вручную.
   - **Автоматизированное (Automated testing):** используются специальные инструменты для автоматического выполнения тестов.

3. **По типу проверки:**
   - **Функциональное:** проверка соответствия функциональных требований.
   - **Нефункциональное:** тестирование производительности, безопасности, удобства использования и других характеристик.
   - **Регрессионное:** проверка, что новые изменения не нарушили работу существующих функций.
   - **Тестирование безопасности, нагрузочное, стрессовое и др.**

---

### 14. Стандарты качества программной документации

**Стандарты качества программной документации** — это совокупность правил и критериев, которым должна соответствовать документация к программному обеспечению, чтобы быть полезной, понятной и поддерживаемой.

**Основные характеристики качественной документации:**
- **Полнота** — вся нужная информация присутствует, нет пробелов.
- **Ясность и понятность** — текст написан простым и однозначным языком, понятен целевой аудитории.
- **Точность** — сведения соответствуют реальному поведению программы, отсутствуют ошибки и неточности.
- **Актуальность** — документация своевременно обновляется при изменении программы.
- **Структурированность** — логичная организация, наличие оглавления, разделов, списков, иллюстраций.
- **Доступность** — легко найти нужную информацию, применяется навигация, индекс, поиск.
- **Краткость** — отсутствие избыточной информации, всё по делу.
- **Согласованность** — единый стиль, терминология и форматирование по всему документу.

**Международные и национальные стандарты:**
- **ГОСТ 19.105-78** — Общие требования к программной документации (Россия, СНГ).
- **ГОСТ 34.602-89** — Техническое задание на создание АС.
- **ISO/IEC/IEEE 26514** — Международный стандарт по требованию к пользовательской документации.
- **IEEE 1063** — Стандарт по написанию пользовательской документации.

---

### 15. Меры и метрики

**Меры и метрики** — это количественные показатели, которые используются для оценки различных характеристик процесса и продукта разработки программного обеспечения.

**Меры** — это количественные значения, получаемые в результате измерения (например, количество строк кода, количество найденных дефектов).

**Метрики** — это производные показатели, которые вычисляются на основе мер для анализа и принятия решений (например, производительность команды, плотность дефектов).

**Примеры мер:**
- Количество строк исходного кода (LOC — Lines of Code)
- Число требований в спецификации
- Количество тестовых случаев
- Число выявленных дефектов

**Примеры метрик:**
- **Плотность дефектов:** количество ошибок на тысячу строк кода
- **Покрытие кода тестами:** процент кода, покрытого тестами
- **Среднее время исправления дефекта**
- **Производительность команды:** количество реализованных требований за спринт

**Для чего нужны меры и метрики:**
- Оценка качества продукта и процесса разработки
- Прогнозирование сроков и трудозатрат
- Определение узких мест и областей для улучшения
- Принятие обоснованных управленческих решений

---

### 16. Тестовое покрытие

**Тестовое покрытие** — это метрика, показывающая, какая часть программного кода была выполнена во время автоматических или ручных тестов.

**Для чего нужно тестовое покрытие:**
- Оценка степени проверенности кода тестами.
- Помогает выявить не протестированные участки программы.
- Повышает качество и надёжность программного продукта.

**Виды тестового покрытия:**
- **Покрытие строк кода (Line coverage):** процент строк, выполненных при тестировании.
- **Покрытие условий (Condition/Branch coverage):** процент логических ветвлений (if, case), которые были выполнены.
- **Покрытие путей (Path coverage):** процент всех возможных путей выполнения кода.
- **Покрытие функций/методов:** процент протестированных функций/методов.

**Как измеряется:**
- Используются специальные инструменты (например, JaCoCo для Java, Coverage.py для Python, Istanbul для JS).
- После запуска тестов формируется отчёт с процентами покрытия.

---

### 17. Тестовый сценарий

**Тестовый сценарий** — это последовательность действий, условий и ожидаемых результатов, предназначенных для проверки одной или нескольких функций программного обеспечения.

**Основные элементы тестового сценария:**
- **Идентификатор** — уникальный номер или название сценария.
- **Название** — краткое описание того, что проверяет сценарий.
- **Предусловия** — состояние системы или необходимые действия, которые должны быть выполнены перед началом теста.
- **Шаги выполнения** — последовательные действия, которые должен выполнить тестировщик.
- **Ожидаемый результат** — что должно произойти после каждого шага или по завершении сценария.
- **Фактический результат** (заполняется после теста) — что реально произошло при выполнении сценария.
- **Статус** — результат теста (пройден/не пройден).

**Пример тестового сценария для интернет-магазина:**

1. **ID:** TC-001  
2. **Название:** Добавление товара в корзину  
3. **Предусловия:** Пользователь авторизован, открыт каталог товаров  
4. **Шаги:**
   1. Выбрать товар из каталога  
   2. Нажать кнопку "Добавить в корзину"  
   3. Открыть корзину  
5. **Ожидаемый результат:**  
   Выбранный товар отображается в корзине с верным названием и ценой.

---

### 18. Тестовый пакет

**Тестовый пакет** — это совокупность взаимосвязанных тестовых сценариев и/или тестовых случаев, объединённых по определённому признаку (например, по функциональности, модулю, типу тестирования) и предназначенных для совместного выполнения.

**Основные характеристики тестового пакета:**
- Включает несколько тестовых сценариев или тест-кейсов, связанных общей целью.
- Позволяет систематизировать тестирование, охватывать определённую часть функционала или аспект системы.
- Может быть настроен для автоматического или ручного запуска (например, в системах CI/CD).

**Структура тестового пакета:**
- **Название пакета**
- **Описание** (какую часть системы покрывает, цель)
- **Список входящих тестовых сценариев/кейсов**
- **Условия выполнения** (например, последовательность или параллельность запуска)
- **Ожидаемый результат** (общий для всего пакета или для каждого теста)

**Пример:**  
Тестовый пакет «Авторизация» может включать сценарии:  
- Вход с правильными данными  
- Вход с неверным паролем  
- Вход с заблокированным пользователем

---

### 19. Анализ спецификаций

**Анализ спецификаций** — это процесс проверки, оценки и улучшения документа с требованиями (спецификации) перед началом разработки.

**Основные задачи анализа спецификаций:**
- Проверка полноты: все ли требования учтены, нет ли пропусков.
- Оценка однозначности формулировок: нет ли двусмысленностей, разночтений.
- Проверка согласованности: нет ли противоречий между требованиями.
- Оценка реализуемости: возможно ли выполнить требования с имеющимися ресурсами и технологиями.
- Проверка тестируемости: можно ли проверить выполнение каждого требования.
- Анализ прослеживаемости: можно ли отследить каждое требование от постановки до реализации и тестирования.
- Уточнение требований: выявление скрытых, неформализованных или избыточных требований.

**Методы анализа спецификаций:**
- **Рецензирование (peer review):** коллективная проверка документа командой.
- **Чек-листы:** использование списков критериев качества требований.
- **Прототипирование:** создание прототипов для проверки понимания требований.
- **Трассировка требований (traceability):** построение связей между требованиями, задачами и тестами.
- **Анализ на соответствие стандартам (например, IEEE, ГОСТ).**

---

### 20. Верификация и аттестация программного обеспечения

**Верификация и аттестация программного обеспечения** — это процессы, направленные на подтверждение качества и соответствия программного продукта установленным требованиям и стандартам.

### Верификация ПО

**Верификация** (от англ. verification) — это процесс проверки, правильно ли реализована система с точки зрения внутренних требований и спецификаций.  
**Вопрос:** "Делаем ли мы продукт правильно?"

**Цели верификации:**
- Убедиться, что продукт соответствует спецификации.
- Найти дефекты на ранних этапах.
- Предотвратить ошибки в реализации.

**Методы верификации:**
- Рецензирование (review) и инспекции документации и кода.
- Анализ и статическое тестирование (без запуска программы).
- Моделирование, трассировка требований.
- Анализ соответствия стандартам.

### Аттестация ПО

**Аттестация** (или валидация, от англ. validation) — это процесс подтверждения, что конечный продукт соответствует ожиданиям и нуждам пользователя, а также установленным стандартам и нормативам.  
**Вопрос:** "Делаем ли мы правильный продукт?"

**Цели аттестации:**
- Убедиться, что ПО решает задачи пользователя.
- Подтвердить пригодность к эксплуатации.
- Получить официальное разрешение на внедрение в промышленную эксплуатацию.

**Методы аттестации:**
- Функциональное и приёмочное тестирование.
- Проведение испытаний по утверждённым методикам.
- Эксплуатационные испытания у заказчика.
- Оформление протоколов испытаний и заключений.

**Различия:**
- **Верификация:** фокус на соответствии внутренним требованиям и спецификациям.
- **Аттестация:** фокус на соответствии ожиданиям пользователя и внешним стандартам.

---
